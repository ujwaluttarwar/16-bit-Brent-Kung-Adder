# Design of 16 bit Brent Kung Adder
## Basics - About Brent Kung Adder
Brent Kung adder is a type of tree adder which is used when higher number of bits are to be added with high speed and low complexity. These adders use the concept of carry look ahead addition. Unlike carry look ahead addition, where the complexity in design increases as the number of bits increases, thereby increasing computation time, Brent Kung adders use tree like architecture, with each node performing very simple operations, creates logarithmic dependence of time on number of bits. Ideally, for say N-bit addition, the Brent Kung adder should take around log(N) units of delay, where 1 unit corresponds to delay due to single node.  
## Working of Brent Kung Adder
![flow](https://github.com/ujwaluttarwar/16-bit-Brent-Kung-Adder/blob/main/flow.png)
The above tree structure is for a 16 bit Brent Kung Adder, where each block represents a unit that generates P and G values. The subscript of P and G indicates the range of index covered while calculating a particular P and G values, while the superscript denotes the level at which the P and G are calculated Each layer calculates the P and G values which are used for calculation of next layer P and G values. For input A (a15 - a0) and B (b15 - b0) and an external input carry C0 (not shown in figure), the Brent Kung Adder works as follows - 
1. Master Equation - G<sup>n</sup> = G<sub>u</sub><sup>n-1</sup> + P<sub>u</sub><sup>n-1</sup> * G<sub>l</sub><sup>n-1</sup> and P<sup>n</sup> = P<sub>u</sub><sup>n-1</sup> * P<sub>l</sub><sup>n-1</sup> where u represents upper half range and l represents lower half range. The n represents the row number for which the G and P needs to be calculated. Hence for n=3 in above figure G<sub>(15:8)</sub><sup>3</sup> = G<sub>15:12</sub><sup>2</sup> + P<sub>15:12</sub><sup>2</sup> * G<sub>12:8</sub><sup>2</sup> and P<sub>15:12</sub><sup>3</sup> = P<sub>15:12</sub><sup>2</sup> * P<sub>12:8</sub><sup>2</sup>
2. The above equation for n = 0 (i.e. the first row) would be given as G<sub>i</sub><sup>0</sup> = a<sub>i</sub> AND b<sub>i</sub> and P<sub>i</sub><sup>0</sup> = a<sub>i</sub> XOR b<sub>i</sub> except G<sub>0</sub><sup>0</sup> =  (a<sub>0</sub> AND b<sub>0</sub>) OR (C<sub>0</sub> AND (a<sub>0</sub> OR b<sub>0</sub>)). 
3. The above G<sub>0</sub><sup>0</sup> make sures that C<sub>1</sub> = G<sub>0</sub><sup>0</sup> and all the other carry-out having index as power of 2 given as c<sub>m</sub> = G<sub>(m-1:0)</sub><sup>log<sub>2</sub>m</sup>
4. Carries at a distance of 1 index from known carries can be calculated using 0th row G and P. Similarly carries at a distance of 2 index can be calculated using 1st row G and P and so on using the equation C<sub>unknown</sub> = G + P * C<sub>known</sub>. This would allow us to calculate all the internal carries.
5. s<sub>n</sub> or the nth bit of sum output is given as P<sub>n</sub><sup>0</sup> * c<sub>n</sub> and the final output carry would be last carry i.e. c<sub>16</sub> (for 16 bit Brent Kung Adder)    
